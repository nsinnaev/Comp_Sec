# -*- coding: utf-8 -*-
"""CSec_HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1455roy7tlua9YIp69QdsEdg0gTm2Az4-
"""

from collections import Counter

def find_repeated_strings(text, n):
    """
    Finds strings of length 'n' that are repeated in 'text'.
    """
    repeated_strings = []
    for i in range(0, len(text) - n):
        if text[i:i + n] == text[i + n:i + 2 * n]:
            repeated_strings.append(text[i:i + n])
    return repeated_strings

def find_common_divisors(numbers):
    """
    Finds common divisors of given list of numbers.
    """
    common_divisors = []
    for i in range(1, min(numbers) + 1):
        if all(num % i == 0 for num in numbers):
            common_divisors.append(i)
    return common_divisors

def vigenere_solver(ciphertext):
    """
    Solves Vigen√®re cipher using Kasiski examination.
    """
    repeated_strings = []
    for i in range(2, len(ciphertext) // 2):
        repeated_strings += find_repeated_strings(ciphertext, i)

    if not repeated_strings:
        return "No repeated strings found. Cannot solve the cipher.", []

    divisible_by = find_common_divisors([len(s) for s in repeated_strings])
    if len(divisible_by) == 1:
        key_length = divisible_by[0]
    else:
        # If there are multiple common divisors, you can use other methods to choose the correct one.
        # For simplicity, I am choosing the largest common divisor here.
        key_length = max(divisible_by)

    plaintext_segments = [ciphertext[i::key_length] for i in range(key_length)]
    frequencies = [Counter(segment) for segment in plaintext_segments]
    return "Estimated key length: " + str(key_length), frequencies

ciphertext = "TTEUMGQNDVEOIOLEDIREMQTGSDAFDRCDYOXIZGZPPTAAITUCSIXFBXYSUNFESQRHISAFHRTQRVSVQNBEEEAQGIBHDVSNARIDANSLEXESXEDSNJAWEXAODDHXEYPKSYEAESRYOETOXYZPPTAAITUCRYBETHXUFINR".lower()
key_length, frequencies = vigenere_solver(ciphertext)
print(f"Estimated key length: {key_length}")
print("Frequencies of segments:")
for i, freq in enumerate(frequencies):
    print(f"Segment {i}: {freq}")

'''
class TrieNode:
    def __init__(self):
        self.children = {}
        self.end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.end_of_word = True

    def search(self, word):
        node = self.root
        for i in range(len(word)):
            for j in range(i + 2, len(word) + 1):
                current_word = word[i:j]
                current_node = self.root
                found = True
                for char in current_word:
                    if char not in current_node.children:
                        found = False
                        break
                    current_node = current_node.children[char]
                if found and current_node.end_of_word:
                    yield current_word


def find_unique_substrings(text):
    trie = Trie()
    words = text.split()
    for word in words:
        trie.insert(word)
    return list(trie.search(text))

print(find_unique_substrings("TTEUMGQNDVEOIOLEDIREMQTGSDAFDRCDYOXIZGZPPTAAITUCSIXFBXYSUNFESQRHISAFHRTQRVSVQNBEEEAQGIBHDVSNARIDANSLEXESXEDSNJAWEXAODDHXEYPKSYEAESRYOETOXYZPPTAAITUCRYBETHXUFINR"))
'''