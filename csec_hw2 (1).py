# -*- coding: utf-8 -*-
"""CSec_HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1455roy7tlua9YIp69QdsEdg0gTm2Az4-
"""

from collections import Counter

def find_repeated_strings(text, n):
    """
    Finds strings of length 'n' that are repeated in 'text'.
    """
    repeated_strings = []
    for i in range(0, len(text) - n):
        if text[i:i + n] == text[i + n:i + 2 * n]:
            repeated_strings.append(text[i:i + n])
    return repeated_strings

def find_common_divisors(numbers):
    """
    Finds common divisors of given list of numbers.
    """
    common_divisors = []
    for i in range(1, min(numbers) + 1):
        if all(num % i == 0 for num in numbers):
            common_divisors.append(i)
    return common_divisors

def vigenere_solver(ciphertext):
    """
    Solves Vigen√®re cipher using Kasiski examination.
    """
    repeated_strings = []
    for i in range(2, len(ciphertext) // 2):
        repeated_strings += find_repeated_strings(ciphertext, i)

    if not repeated_strings:
        return "No repeated strings found. Cannot solve the cipher.", []

    divisible_by = find_common_divisors([len(s) for s in repeated_strings])
    if len(divisible_by) == 1:
        key_length = divisible_by[0]
    else:
        # If there are multiple common divisors, you can use other methods to choose the correct one.
        # For simplicity, I am choosing the largest common divisor here.
        key_length = max(divisible_by)

    plaintext_segments = [ciphertext[i::key_length] for i in range(key_length)]
    frequencies = [Counter(segment) for segment in plaintext_segments]
    return "Estimated key length: " + str(key_length), frequencies

ciphertext = "TTEUMGQNDVEOIOLEDIREMQTGSDAFDRCDYOXIZGZPPTAAITUCSIXFBXYSUNFESQRHISAFHRTQRVSVQNBEEEAQGIBHDVSNARIDANSLEXESXEDSNJAWEXAODDHXEYPKSYEAESRYOETOXYZPPTAAITUCRYBETHXUFINR".lower()
key_length, frequencies = vigenere_solver(ciphertext)
print(f"Estimated key length: {key_length}")
print("Frequencies of segments:")
for i, freq in enumerate(frequencies):
    print(f"Segment {i}: {freq}")

'''
class TrieNode:
    def __init__(self):
        self.children = {}
        self.end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.end_of_word = True

    def search(self, word):
        node = self.root
        for i in range(len(word)):
            for j in range(i + 2, len(word) + 1):
                current_word = word[i:j]
                current_node = self.root
                found = True
                for char in current_word:
                    if char not in current_node.children:
                        found = False
                        break
                    current_node = current_node.children[char]
                if found and current_node.end_of_word:
                    yield current_word


def find_unique_substrings(text):
    trie = Trie()
    words = text.split()
    for word in words:
        trie.insert(word)
    return list(trie.search(text))

print(find_unique_substrings("TTEUMGQNDVEOIOLEDIREMQTGSDAFDRCDYOXIZGZPPTAAITUCSIXFBXYSUNFESQRHISAFHRTQRVSVQNBEEEAQGIBHDVSNARIDANSLEXESXEDSNJAWEXAODDHXEYPKSYEAESRYOETOXYZPPTAAITUCRYBETHXUFINR"))
'''

def string_to_bits(s):
    return ''.join(format(ord(x), '08b') for x in s)

def bits_to_string(b):
    return ''.join(chr(int(b[i:i+8], 2)) for i in range(0, len(b), 8))

def des_round_keys(key):
    # Initial Permutation of the key
    pc1 = [57, 49, 41, 33, 25, 17, 9,
           1, 58, 50, 42, 34, 26, 18,
           10, 2, 59, 51, 43, 35, 27,
           19, 11, 3, 60, 52, 44, 36,
           63, 55, 47, 39, 31, 23, 15,
           7, 62, 54, 46, 38, 30, 22,
           14, 6, 61, 53, 45, 37, 29,
           21, 13, 5, 28, 20, 12, 4]

    # Compression Permutation
    pc2 = [14, 17, 11, 24, 1, 5, 3, 28,
           15, 6, 21, 10, 23, 19, 12, 4,
           26, 8, 16, 7, 27, 20, 13, 2,
           41, 52, 31, 37, 47, 55, 30, 40,
           51, 45, 33, 48, 44, 49, 39, 56,
           34, 53, 46, 42, 50, 36, 29, 32]

    # Left shift schedule
    shifts = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

    # Perform the initial permutation on the key
    key = [key[i - 1] for i in pc1]

    round_keys = []
    for shift in shifts:
        # Split the key into left and right halves
        left = key[:28]
        right = key[28:]

        # Perform circular left shifts
        left = left[shift:] + left[:shift]
        right = right[shift:] + right[:shift]

        # Combine the halves
        key = left + right

        # Apply compression permutation to generate round key
        round_key = [key[i - 1] for i in pc2]
        round_keys.append(round_key)

    return round_keys

def des_f_function(r_block, round_key):
    # Expansion permutation
    expansion_permutation = [32, 1, 2, 3, 4, 5,
                             4, 5, 6, 7, 8, 9,
                             8, 9, 10, 11, 12, 13,
                             12, 13, 14, 15, 16, 17,
                             16, 17, 18, 19, 20, 21,
                             20, 21, 22, 23, 24, 25,
                             24, 25, 26, 27, 28, 29,
                             28, 29, 30, 31, 32, 1]

    # Permutation function P
    permutation_p = [16, 7, 20, 21, 29, 12, 28, 17,
                     1, 15, 23, 26, 5, 18, 31, 10,
                     2, 8, 24, 14, 32, 27, 3, 9,
                     19, 13, 30, 6, 22, 11, 4, 25]

    # Expansion permutation
    expanded_r = [r_block[i - 1] for i in expansion_permutation]

    # XOR with round key
    xor_result = [int(expanded_r[i]) ^ int(round_key[i]) for i in range(48)]

    # S-boxes
    s_boxes = [
        # S1
        [
            [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
            [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
            [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
            [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
        ],
        # S2
        [
            [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
            [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
            [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
            [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
        ],
        # S3
        [
            [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
            [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
            [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
            [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
        ]
    ]

    # S-box substitution
    s_box_output = []
    for i in range(8):
        row = int(''.join(map(str, [xor_result[i * 6], xor_result[i * 6 + 5]])), 2)
        col = int(''.join(map(str, xor_result[i * 6 + 1:i * 6 + 5])), 2)
        s_box_output.extend([int(x) for x in format(s_boxes[i][row][col], '04b')])

    # Permutation function P
    permuted_output = [s_box_output[i - 1] for i in permutation_p]

    return permuted_output

def des_decrypt(ciphertext, key):
    # Generate round keys
    round_keys = des_round_keys(key)

    # Initial permutation for ciphertext
    initial_permutation = [58, 50, 42, 34, 26, 18, 10, 2,
                           60, 52, 44, 36, 28, 20, 12, 4,
                           62, 54, 46, 38, 30, 22, 14, 6,
                           64, 56, 48, 40, 32, 24, 16, 8,
                           57, 49, 41, 33, 25, 17, 9, 1,
                           59, 51, 43, 35, 27, 19, 11, 3,
                           61, 53, 45, 37, 29, 21, 13, 5,
                           63, 55, 47, 39, 31, 23, 15, 7]

    plaintext_binary = [ciphertext[i - 1] for i in initial_permutation]

    # Divide plaintext into left and right halves
    left_half = plaintext_binary[:32]
    right_half = plaintext_binary[32:]

    # Decrypt each round
    for round_num in range(16):
        round_key = round_keys[15 - round_num]

        # Perform f-function
        f_output = des_f_function(right_half, round_key)

        # XOR with left half
        new_right_half = [int(left_half[i]) ^ int(f_output[i]) for i in range(32)]

        # Update left and right halves for next round
        left_half = right_half
        right_half = new_right_half

    # Final permutation
    final_permutation = [40, 8, 48, 16, 56, 24, 64, 32,
                         39, 7, 47, 15, 55, 23, 63, 31,
                         38, 6, 46, 14, 54, 22, 62, 30,
                         37, 5, 45, 13, 53, 21, 61, 29,
                         36, 4, 44, 12, 52, 20, 60, 28,
                         35, 3, 43, 11, 51, 19, 59, 27,
                         34, 2, 42, 10, 50, 18, 58, 26,
                         33, 1, 41, 9, 49, 17, 57, 25]

    plaintext_binary = [plaintext_binary[i - 1] for i in final_permutation]

    # Convert binary plaintext to string
    plaintext = bits_to_string(''.join(map(str, plaintext_binary)))

    return plaintext

# Ciphertext in binary format
ciphertext_binary = "1100101011101101101000100110010101011111101101110011100001110011"

# Key in binary format
key_binary = "0100110001001111010101100100010101000011010100110100111001000100"

# Decrypt the ciphertext
plaintext = des_decrypt(ciphertext_binary, key_binary)
print("Decrypted plaintext:", plaintext)